\chapter{Описание ПО}
\label{ch:impl}

\section{Структура сервиса}

Так как подсистема взаимодействия с пользователем была использована
с предыдущей версии сервиса %todo ссылка на раздел анализа требований, где это написано
, а обе подсистемы хранения данных представляют из себя
готовый сторонний продукт, в этом разделе будет подробно описана
структура подсистемы для сбора данных по call-центру.

Подсистема для сбора данных по call-центру (NauSnitch) представляет из себя
отдельный сервис, компилирующийся в исполняемый файл.
Общение с подсистемой взаимодействия с пользователем
происходит посредством общей шины сообщений NauCore как показано на рисунке~\ref{общая-архитектура-archimate}.

Подсистема построена на базе event-driven архитектуры %todo ссылка на архитектуру
с применением реактивных принципов проектирования. %todo ссылка на реакит манифест

В NauSnitch можно выделить основные модули (рисунок~\ref{диаграмма-блоков}):
\begin{itemize}
    \item главный модуль, содержащий точку входа в программу
    и основной класс для управления поведением сервиса;
    \item модуль для обработки изменений состояния операторов и звонков;
    \item модуль для работы с БД;
    \item модуль конфигурирования;
    \item реализация клиента шины NauCore.
\end{itemize}
Помимо вышеперечисленных модулей, есть код, ни относящийся ни к одному из них,
было принято решение переместить его в отдельный пакет, с названием utils.

\subsection{Главный модуль}

Главный модуль выполняет задачи запуска приложения, остановки и является связующим звеном между остальными модулями.
Он состоит из функции main и структуры Snitch.

Функция main является точкой входа в программу, там же происходит конфигурирование, запуск фоновых задач
и создание главной связующей структуры --- Snitch.

Структура Snitch выполняет следующие функции:
\begin{itemize}
    \item через интерфейс доступа к шине~\ref{глава-с-описанием-npilib}
    регистрируется на шине NauCore;
    \item подписывается на нужные события %todo описанные в главе такой-то
    и перенаправляет их в модуль доменной логики~\ref{глава-с-описанием-модуля-логики};
    \item регистрирует свои интерфейсы %todo см описание в главе такой-то
    на шине;
    \item следит за состоянием используемых сервисов, что бы в случае их отключение остановить работу, связанной с ними частью логики,
    либо, наоборот, при их включении запустить связанную логику;
    \item выполняет переодические фоновые задачи.
\end{itemize}

\Define{NauQPM}{} %todo
\Define{NauBuddy}{}
\Define{NauDialer}{}
\Define{NauCRM}{название интерфейса PMS на шине}
Snitch использует информацию полученную от следующих сервисов:
\begin{itemize}
    \item NauQPM --- информация для обновления настроек проектов;
    \item NauBuddy --- обновление состояния звонков и операторов;
    \item NauDialer --- получение списка доступных номеров по проектам;
    \item NauCRM --- получение настроек снитча.
\end{itemize}

Snitch использует следующие интерфейсы:
\begin{enumerate} %todo передать в таблицу
    \item NauQPM:
    \begin{enumerate}
        \item Event:FullProjectsConfig --- получение списка всех активных проектов;
        \item Event:ProjectsConfigChanged --- получение только измененных проектов с последнего такого сообщения;
    \end{enumerate}
    \item NauBuddy:
    \begin{enumerate}
        \item FullBuddyList --- список свойств всех зарегестрированных операторов в NCC;
        \item ShortBuddyList --- список свойств только одного оператора, по которому произошли изменения;
        \item BuddyListDiff --- список добавленных и удаленных операторов с момента последнего получения такого сообщения;
        \item FullCallsList --- список всех осуществляемых в данный момент вызовов;
        \item ShortCallsList --- только один вызов, по которому произошли изменения;
    \end{enumerate}
    \item NauDialer
    \begin{enumerate}
        \item Request:CallsListsInfo --- содержит список доступных нумеров по всем проектам;
    \end{enumerate}
    \item NauCRM:
    \begin{enumerate}
        \item Request:ProjectsThresholds --- содержит настройки всех проектов.
    \end{enumerate}
\end{enumerate}

Snitch регистрирует следующие интерфейсы:
\begin{enumerate} %todo переделать на таблицу
    \item Request:ModifyProjectThreshold --- запрос на внесение изменений по указанным проектам, отправляет NauCRM;
    \item Request:SubscribeToSLChange --- подписка на сообщения об измении SL\@; %todo кто использует?
    \item Request:UnsubscribeFromSLChange --- отписка от сообщений об измении SL\@.
\end{enumerate}

Так же Snitch выполняет следующие фоновые задачи:
\begin{enumerate} %todo переделать на таблицу название, описание, время срабатывания
    \item обновление SL --- задача запускается каждую минуту и пытается обновить SL,
    если SL обновился, отправляет сообщение Event:SLChange всем, кто подписался на обновление;
    \item сохранение сводок в БД --- сохраняет суммарную информацию по проектам и заблокированным вызовам,
    время запуска конфигурируется с помощью настройки Database.CreateSummaryInterval (см.~в~таблице~\ref{tab:snitch:setting}); %todo см описание конфигурации
    \item очистка данных в БД --- очищает данных в подсистеме хранение нечувствительной ко времени информации,
    время запуска конфигурируется с помощью настройки Database.CleanDBInterval (см.~в~таблице~\ref{tab:snitch:setting});
    \item обновление настроек проектов --- после регистрации интерфейса NauCRM запускается задача обновления настроек проектов,
    время запуска фиксированное и равно 30 секунд.
\end{enumerate}

\subsection{Модуль конфигурирования}

Модуль конфигурирования отвечат за загрузку, десериализацию из специального формата
и предоставление в удобной форме всех настроек сервиса, описание которых приводится в таблице~\ref{tab:snitch:setting}.
Настройки могут храниться в любом из форматов: JSON, TOML, YAML, HCL и формат свойств джавы.
\Define{Consul}{}
Так же настройки могут быть получены из удаленного сервиса, такого как Consul\@,
либо заданы как переменные среды (пример файла конфигурации приведен в приложении~\ref{}).

Все настройки загружаются из источника один раз при старте сервиса и в дальнейшем,
для их изменения требуется перезагрузка,
но это не относится к конфигурированию уровня логгирования,
оно обновляется сразу же, как были внесены изменения в файл настроек.

\begin{small} %todo вынести в приложение что ли?
\begin{longtable}{|p{0.15\textwidth}|p{0.2\textwidth}|p{0.1\textwidth}|p{0.5\textwidth}|}
    \caption{Описание настроек подсистемы для сбора данных по call-центру}
    \label{tab:snitch:setting}
    \\ \hline
    Название & Код & Значение по умолчанию & Описание \\
    \hline \endfirsthead
    \hline
    Название & Код & Значение по умолчанию & Описание \\
    \hline
    \endhead
    \hline \endlastfoot
    Адрес NauCore & Bus.Address & localhost:3242 & TCP/IP адрес до NauCore \\
    \hline
    Максимальный размер сообщения & Bus.MaxPayload & 3145728 & Максимальный размер сообщения, который может принять NauSnitch, в байтах \\
    \hline
    Путь до key-файла & KeyFile & /opt/naumen/nauphone/cfg/naucore/key.service.nausnitch.xml & Путь до файла ключа к шине \\
    \hline
    Уровень лога & Log.Level & info & Максимальный уровень с которым будут выведены сообщения в лог, может принимать значения по возрастанию: panic, fatal, error, (warn, warning), info, debug \\
    \hline
    Вывод лога & Log.File & stdout & Файл, куда будет записан вывод лога, если не указан, выводит сообщения в стандартный поток вывода \\
    \hline
    Драйвер БД & Database.Driver & postgres & Драйвер, который будет использоваться для доступа к бд, возможные значения: postgres, oracle \\
    \hline
    Путь до БД & Database.DataSource & postgres://naucrm:naucrm@localhost/naumendb?sslmode=disable & Путь до БД, у каждого драйвера может быть свой формат \\
    \hline
    Максимальное количество соединений & Database.MaxConns & 10 & Максимальное количество одновременных соединений к БД \\
    \hline
    Интервал сохранения сводки & Database.CreateSummaryInterval & 20s &
    Интервал, через который будут сохраняться сводки в БД, буквенный суффикс означает единицу измерения и может быть:
    \begin{itemize}
        \item s --- секунда
        \item m --- минута
        \item h --- час
    \end{itemize}
    ед. измерения могут быть скомбинированы, например: 2h30m \\
    \hline
    Интервал очистки БД & Database.CleanDBInterval & 30m & Интервал, через который будут очищены все данные в БД \\
    \hline
    Путь до Redis & Redis.URL & localhost:6379 & Путь до БД Redis, задается в формате URL \\
    \hline
    Таймаут подключения к Redis & Redis.ConnTimeout & 1m & Таймаут для подключение к Redis, через заданный промежуток времени, если соединение не удалось, прекращается попытка соединения и возвращается ошибка \\
    \hline
    Номер БД в Redis & Redis.DB & 0 & \\
    \hline
    Таймаут операции в Redis & Redis.ConnTimeout & 1m & Таймаут для выполенение одной операции, если она выполняется дольше заданного времени, то операция прекращается и возврашается ошибка \\
    \hline
    Пароль от Redis & Redis.Password & -- & Пароль от Redis, задается только в случае, если указан \\
    \hline
    Количество соединений к Redis & Redis.PoolSize & 10 & Максимальное количество соединений к Redis \\
    \hline
    Определение номеров как внешних & InnerAsOuter & -- & Настройка нужна для тестирования,
    заставляет NauSnitch перечисленные номера считать как внешние \\
    \hline
    Порт для отладки & DebugPort & -- & TCP порт, к которому можно подключиться для отладки \\
    \hline
    Максимальное количество активных операторов & Snitch.Agent.MaxActive & 2000 & Максимальное количество одновременных
    операторов, которые может обработать NauSnitch, если одновременных операторов оказалось больше, чем задано в настройке, они будут помещены в очередь обработки.
    Чем больше значение, тем больше нужно ОЗУ и выше нагрузка на БД и ЦП \\
    \hline
    Максимальное количество активных звонков & Snitch.Call.MaxActive & 500 & То же самое,
    что и Snitch.Agent.MaxActive, только для звонков \\
    \hline
    Граница начала предупреждения о количестве активных операторов & Snitch.Agent.NotificationBorderCoeff &
    0.05 & Задает верхнюю границу, с какого количества активных операторов в логе начнут появлятся предупреждения, может принимать значение от 0 до 1,
    граница рассчитывается как: $Snitch.Agent.MaxActive * Snitch.Agent.NotificationBorderCoeff$,
    т.е. если оставить значение по умолчанию, она будет равна: 100 активных операторов \\
    \hline
    Граница начала предупреждения о количестве активных звонков & Snitch.Call.NotificationBorderCoeff &
    0.2 & То же, что и для операторов, но рассчитывается по настройкам по звонкам \\
    \hline
    Шаг предупреждения по операторам & Snitch.Agent.NotificationStep & 100 &
    Определяет, с каким шагом будут выдаваться предупреждения, по умолчанию на каждую сотню операторов \\
    \hline
    Шаг предупреждения по звонкам & Snitch.Call.NotificationStep & 20 &
    То же, что и для операторов, но для звонков \\
    \hline
    Максимальное количество изменений на одного оператора & Snitch.Agent.Task.MaxAtSameTime & 20 &
    Фактически ограничивает количество сообщений ShortBuddyList, которые могут прийти примерно в 200-500 миллисекунд,
    увеличение размера приводит к увеличению потребления ОЗУ \\
    \hline
    Максимальное количество изменений на один звонок & Snitch.Call.Task.MaxAtSameTime & 20 &
    То же, что и Snitch.Agent.Task.MaxAtSameTime, но для звонков и ограничивает количество ShortCallsList \\
    \hline
    Граница начала предупреждения о количестве изменений на одного оператора & Snitch.Agent.Task.NotificationBorderCoeff & 0.5 &
    Коэффициент задает границу, с которой начнутся предупреждения в логе \\
    \hline
    Граница начала предупреждения о количестве изменений на один звонок & Snitch.Call.Task.NotificationBorderCoeff & 0.8 &
    То же \\
    \hline
    Шаг предупреждения по одновременным изменениям на одного оператора & Snitch.Agent.Task.NotificationStep & 5 &
    Определяет, с каким шагом будут выдаваться предупреждения, по умолчанию на каждое пятое обновление на одного оператора \\
    \hline
    Шаг предупреждения по одновременным изменениям на один звонок & Snitch.Call.Task.NotificationStep & 2 &
    То же \\
\end{longtable}
\end{small}

\subsection{Модуль для работы с БД}

Взаимодействие с БД реализовано посредством паттерна <<шлюз к данным записи>> (Row Data Gateway)~\cite{fauler2019}:
для каждой таблицы в БД %todo смотри раздел описание БД
была создана структура в коде, которая полностью повторяет все атрибуты
и имеет методы для взаимодействия с БД.

В процессе нагрузочного тестирования была обнаружена высокая нагрузка
на БД, создаваемая сервисом NauSnitch.
Нагрузка появлялась из-за сохранение большого количества
небольших порций данных, каждую в своей транзации.
В связи с этим, был разработан интерфейс отложенного сохранения данных в БД.
Структура SchedulingRepository накапливает все данные, которые должны быть сохранены и,
с заданной периодичностью, сохраняет их в БД в одной транзакции.
При этом, процесс сохранение данных выполняется в паралелльном потоке и не замедляет работу программы.
В дальнейшем, под сохранением значений в БД подразумевается именно отложенное сохранение.

%todo все шлюзы представлены на диаграмме~\ref{}

Взаимодействие с Redis осуществляется с помощью паттерна <<репозиторий>>, %todo ссылка на описание https://medium.com/@pererikbergman/repository-design-pattern-e28c0f3e4a30
но с некоторыми модификациями, например, команды объеденены не по сущностям, а по контексту использования. %todo Репозитории представлены на диаграмме~\ref{}

\subsection{Модуль для обработки изменений состояния операторов и звонков}

Все сообщения по изменению сосотояния операторов или звонков, которые были получены,
отправляются в этот модуль, при чем,
для каждого оператора или звонка существует очередь, в которую попадает сообщение,
поэтому обработка сообщений по каждому оператору или звонку происходит параллельно, %todo подробнее о работе очереди написано в разделе алгоритмов

Модуль обработки изменений можно разделить на две почти не пересекающихся части: обработка изменений по операторам и по звонкам.

%todo диаграмму классов для обработки звонков можно увидеть на следующем рисунке~\ref{}

Обработкой звонков занимается структура CallProcessor.
Эта структура выполняет следующие функции:
\begin{itemize}
    \item сохраняет в кэш все активные звонки с момента их создания до окончания вызова;
    \item создает и определяет тип звонка в случае, если его нет в кэше; %todo алгоритм определение звонка
    \item принимает сообщения FullCallsList и ShortCallsList и обновляет состояние звонков через интерфейс Call;
    \item завершает звонок и сохраняет его в БД, если пришло сообщение об окончании вызова.
\end{itemize}

%todo нужно описание изменения состояния звонков и операторов показать на диаграмме состояния
Вся логика по звонкам скрыта в структурах:
\begin{itemize}
    \item callInfoBase --- реализует интерфейс Call и общие функции;
    \item InnerCallInfo --- реализует методы для обработки внутренних вызовов; %todo алгоритм работы в след разделе
    \item OutboundCallInfo --- реализует методы для обработки исходящих вызовов;
    \item InboundCallInfo --- реализует методы для обработки входящих вызовов;
    \item legInfo и legsCollection --- инкапсулирует логику для доступа и определения типа плеча вызова~%\cite{naumen:структура-вызова-и-его-идентификатор}.
\end{itemize}

%todo диаграмму классов для обработки операторов можно увидеть на следующем рисунке~\ref{}

Основной структурой для управления потоком обработки сообщений является AgentModel, которая выполняет следующие функции:
\begin{itemize}
    \item обработка сообщений FullBuddyList, ShortBuddyList и BuddyListDiff;
    \item изменение состояния операторов;
    \item сохранение всех изменений в БД.
\end{itemize}

\subsection{Реализация клиента шины NauCore}

\Abbrev{NATS}{}
Клиент шины NauCore состоит из трех основных частей: %todo диаграмма блоков или классов?
\begin{itemize}
    \item шина данных NATS~%\cite{},
    которая выполняет роль интерфейса для снитча; %todo
    \item шлюз между шиной NauCore и NATS;
    \item надстройка над стандартным клиентом NATS\@.
\end{itemize}

%todo переместить это в анализ требований
Шина обмена сообщений NauCore и используемый протокол NCC, NCC2 и NCCN является
внутренней проприетарной разработкой.
Этот факт сильно ограничивает выбор реализаций этого протокола,
на момент начала разработки были доступны реализации на языках программирования: C, Java и Python.
Таким образом, требовалось написать новую реализацию протокола на Go.
При этом она должна удовлетворять требованиям по производительности
и уметь работать с сообщениями асинхронно.
Такая реализация требовала большого количества времени и сил,
поэтому было решено сделать шлюз между NauCore и
уже существующей популярной высокопроизводительной open-source шиной,
к которой есть реализация клиента на языка Go.
И такой шиной является NATS, к тому же она сама написана на языке Go,
что, в дальнейшем, позволило интегрировать ее в NauSnitch.

Шлюз выполняет следующие функции:
\begin{itemize}
    \item регистрация на NauCore
    \item сокрытие механизмов работы NauCore, таких как: регистрация интерфейсов или виртуальных пиров;
    \item конвертация сообщений протокола NCC в сообщения протокола NATS и обратно; %todo описание алгоритмов
    \item мониторинг состояния подключения к шине, оповещение клиентов NATS и переподключение, в случае разрыва соединения. %todo описание алгоритмов
\end{itemize}

%todo Функциональность шлюза разделена на несколько структур.
%Управлением настройками, а так же соединением с NauCore занимается структура Gateway.

Надстройка над стандартным клиентом NATS упрощает работу с шлюзом через NATS,
реализуя удобный API для:
\begin{itemize}
    \item регистрации интерфейсов;
    \item обработки события переподключения к шине;
    \item работы с системными сообщениями NauCore;
    \item обработки событий регистрации или удаления интерфейсов;
    \item синхронной и асинхронной подписки на сообщения с шины;
    \item отправки различных типов сообщений, абстрагируясь над типами, которые предоставляет NATS\@
\end{itemize}

\section{Алгоритм работы NauSnitch}

Алгоритм обработки сообщений в общем виде изображен на диаграмме~\ref{activity-общий-алгоритм-работы}.
%todo описать что происходит на диаграмме


\section{Описание таблицы БД} %todo mb схема данных

\section{Диаграммы UML} %todo mb объектная схема
